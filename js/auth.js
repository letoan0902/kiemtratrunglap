// H·ªá th·ªëng x√°c th·ª±c s·ª≠ d·ª•ng Firebase v9+ SDK v·ªõi b·∫£o m·∫≠t n√¢ng cao
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.11.1/firebase-analytics.js";
import {
  getFirestore,
  collection,
  doc,
  setDoc,
  getDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  query,
  where,
  orderBy,
  serverTimestamp,
  arrayUnion,
  arrayRemove,
} from "https://www.gstatic.com/firebasejs/10.11.1/firebase-firestore.js";

// Nh·∫≠p c·∫•u h√¨nh b·∫£o m·∫≠t
import { configManager, rateLimiter } from "./config.js";

// Instance ·ª©ng d·ª•ng Firebase
let app = null;
let analytics = null;
let db = null;

// Theo d√µi b·∫£o m·∫≠t t·ªëi ∆∞u
class SecurityMonitor {
  constructor() {
    this.suspiciousActivity = [];
    this.failedAttempts = new Map();
    this.maxFailedAttempts = 5;
    this.blockDuration = 300000; // 5 ph√∫t
    this.initialized = false;
  }

  // Kh·ªüi t·∫°o l∆∞·ªùi
  init() {
    if (this.initialized) return;
    this.initialized = true;

    // D·ªçn d·∫πp d·ªØ li·ªáu c≈© ƒë·ªãnh k·ª≥ (n·ªÅn)
    setInterval(() => {
      this.cleanup();
    }, 60000); // M·ªói ph√∫t
  }

  logActivity(type, details = {}) {
    // Kh·ªüi t·∫°o l∆∞·ªùi khi s·ª≠ d·ª•ng l·∫ßn ƒë·∫ßu
    if (!this.initialized) this.init();

    const activity = {
      type,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent.slice(0, 100), // C·∫Øt ng·∫Øn ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t
      details,
    };

    this.suspiciousActivity.push(activity);

    // Ch·ªâ gi·ªØ 50 ho·∫°t ƒë·ªông g·∫ßn nh·∫•t (gi·∫£m t·ª´ 100)
    if (this.suspiciousActivity.length > 50) {
      this.suspiciousActivity = this.suspiciousActivity.slice(-50);
    }
  }

  recordFailedAttempt(identifier) {
    if (!this.failedAttempts.has(identifier)) {
      this.failedAttempts.set(identifier, []);
    }

    const attempts = this.failedAttempts.get(identifier);
    attempts.push(Date.now());

    // Gi·ªõi h·∫°n s·ªë l·∫ßn th·ª≠ ƒë∆∞·ª£c l∆∞u tr·ªØ
    if (attempts.length > this.maxFailedAttempts * 2) {
      attempts.splice(0, attempts.length - this.maxFailedAttempts);
    }
  }

  isBlocked(identifier) {
    if (!this.failedAttempts.has(identifier)) {
      return false;
    }

    const attempts = this.failedAttempts.get(identifier);
    const cutoff = Date.now() - this.blockDuration;
    const recentAttempts = attempts.filter((time) => time > cutoff);

    return recentAttempts.length >= this.maxFailedAttempts;
  }

  clearFailedAttempts(identifier) {
    this.failedAttempts.delete(identifier);
  }

  // D·ªçn d·∫πp n·ªÅn
  cleanup() {
    const cutoff = Date.now() - this.blockDuration;

    for (const [identifier, attempts] of this.failedAttempts.entries()) {
      const validAttempts = attempts.filter((time) => time > cutoff);

      if (validAttempts.length === 0) {
        this.failedAttempts.delete(identifier);
      } else {
        this.failedAttempts.set(identifier, validAttempts);
      }
    }
  }
}

class AuthSystem {
  constructor() {
    this.currentUser = null;
    this.db = null;
    this.securityMonitor = new SecurityMonitor();
    this.initialized = false;
    this.cache = new Map();
    this.monitoringSetup = false;

    // Kh·ªüi t·∫°o kh√¥ng ƒë·ªìng b·ªô nhanh
    this.initPromise = this.init();
  }

  async init() {
    try {
      // Kh·ªüi t·∫°o song song ƒë·ªÉ tƒÉng t·ªëc
      const [securityCheck, firebaseConfig] = await Promise.all([
        configManager.performSecurityChecks(),
        configManager.getConfig(),
      ]);

      // Kh·ªüi t·∫°o Firebase v·ªõi c·∫•u h√¨nh b·∫£o m·∫≠t
      app = initializeApp(firebaseConfig);
      this.db = getFirestore(app);

      // T·∫£i Analytics l∆∞·ªùi (kh√¥ng ch·∫∑n)
      setTimeout(() => {
        analytics = getAnalytics(app);
      }, 0);

      this.initialized = true;

      // Ki·ªÉm tra session storage cho ng∆∞·ªùi d√πng hi·ªán t·∫°i (song song)
      const savedUser = sessionStorage.getItem("currentUser");
      if (savedUser) {
        try {
          this.currentUser = JSON.parse(savedUser);
          console.log("T√¨m th·∫•y user ƒë√£ l∆∞u:", {
            email: this.currentUser.email,
            role: this.currentUser.role,
            currentPage: window.location.pathname,
          });

          // X√°c minh ng∆∞·ªùi d√πng kh√¥ng ƒë·ªìng b·ªô (kh√¥ng ch·∫∑n UI)
          // Th√™m delay ƒë·ªÉ tr√°nh loop redirect
          setTimeout(async () => {
            try {
              const exists = await this.verifyUserExists(
                this.currentUser.email
              );
              console.log("K·∫øt qu·∫£ x√°c minh user:", {
                email: this.currentUser.email,
                exists: exists,
              });

              if (!exists) {
                console.log("X√°c minh user th·∫•t b·∫°i - ƒëƒÉng xu·∫•t");
                this.logout();
              } else {
                console.log("X√°c minh user th√†nh c√¥ng - ki·ªÉm tra trang");

                // Ch·ªâ redirect n·∫øu ƒëang ·ªü trang sai
                const currentPage = window.location.pathname.split("/").pop();
                const expectedPage =
                  this.currentUser.role === "admin"
                    ? "admin.html"
                    : "user.html";

                if (
                  currentPage !== expectedPage &&
                  currentPage !== "index.html"
                ) {
                  console.log("Redirect ƒë·∫øn panel ph√π h·ª£p:", {
                    currentPage: currentPage,
                    expectedPage: expectedPage,
                  });
                  this.redirectToAppropriatePanel();
                }
              }
            } catch (error) {
              console.error("L·ªói trong qu√° tr√¨nh x√°c minh user:", error);
              // Kh√¥ng logout n·∫øu c√≥ l·ªói network, ch·ªâ log
            }
          }, 1000); // Delay 1 gi√¢y ƒë·ªÉ tr√°nh redirect ngay l·∫≠p t·ª©c
        } catch (e) {
          console.log("D·ªØ li·ªáu session kh√¥ng h·ª£p l·ªá, ƒëang x√≥a:", e);
          // D·ªØ li·ªáu session kh√¥ng h·ª£p l·ªá
          sessionStorage.removeItem("currentUser");
        }
      }

      // Thi·∫øt l·∫≠p theo d√µi b·∫£o m·∫≠t l∆∞·ªùi
      setTimeout(() => {
        this.setupSecurityMonitoring();
      }, 1000);
    } catch (error) {
      console.error("Kh√¥ng th·ªÉ kh·ªüi t·∫°o h·ªá th·ªëng x√°c th·ª±c:", error);
      this.handleInitializationError(error);
    }
  }

  setupSecurityMonitoring() {
    if (this.monitoringSetup) return;
    this.monitoringSetup = true;

    // Theo d√µi ho·∫°t ƒë·ªông t·ªëi ∆∞u
    let lastActivity = Date.now();
    let idleCheckInterval = null;

    // B·ªô theo d√µi ho·∫°t ƒë·ªông c√≥ gi·ªõi h·∫°n
    const throttledActivityUpdate = this.throttle(() => {
      lastActivity = Date.now();
    }, 1000); // C·∫≠p nh·∫≠t t·ªëi ƒëa m·ªói gi√¢y m·ªôt l·∫ßn

    // Tr√¨nh nghe s·ª± ki·ªán hi·ªáu qu·∫£
    const events = ["click", "keypress", "scroll"];
    events.forEach((eventType) => {
      document.addEventListener(eventType, throttledActivityUpdate, {
        passive: true,
        capture: false,
      });
    });

    // Ki·ªÉm tra idle t·ªëi ∆∞u (m·ªói 2 ph√∫t thay v√¨ 1)
    idleCheckInterval = setInterval(() => {
      const idleTime = Date.now() - lastActivity;
      if (idleTime > 1800000 && this.isLoggedIn()) {
        // 30 ph√∫t kh√¥ng ho·∫°t ƒë·ªông
        this.securityMonitor.logActivity("idle_timeout");
        this.logout();
        clearInterval(idleCheckInterval);
      }
    }, 120000); // Ki·ªÉm tra m·ªói 2 ph√∫t

    // Theo d√µi kh·∫£ nƒÉng hi·ªÉn th·ªã trang ƒë∆°n gi·∫£n
    document.addEventListener(
      "visibilitychange",
      () => {
        if (document.hidden) {
          lastActivity = Date.now() - 300000; // ƒê√°nh d·∫•u l√† idle 5 ph√∫t khi ·∫©n
        } else {
          lastActivity = Date.now();
        }
      },
      { passive: true }
    );
  }

  // H√†m helper throttle ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t
  throttle(func, limit) {
    let inThrottle;
    return function () {
      const args = arguments;
      const context = this;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  handleInitializationError(error) {
    // UI b√°o l·ªói nh·∫π
    document.body.innerHTML = `
      <div style="display:flex;justify-content:center;align-items:center;height:100vh;font-family:Arial,sans-serif;background:#fff8e1;">
        <div style="text-align:center;padding:40px;background:white;border-radius:20px;box-shadow:0 15px 35px rgba(0,0,0,0.1);max-width:400px;">
          <h2 style="color:#f44336;margin-bottom:20px;">üîí L·ªói B·∫£o M·∫≠t</h2>
          <p style="color:#666;margin-bottom:30px;">·ª®ng d·ª•ng kh√¥ng th·ªÉ kh·ªüi t·∫°o do l·ªói b·∫£o m·∫≠t.</p>
          <button onclick="location.reload()" style="background:#ff6b35;color:white;border:none;padding:12px 24px;border-radius:8px;cursor:pointer;font-weight:600;">Th·ª≠ l·∫°i</button>
        </div>
      </div>`;
  }

  async verifyUserExists(email) {
    try {
      console.log("verifyUserExists ƒë∆∞·ª£c g·ªçi v·ªõi email:", email);

      // Ki·ªÉm tra cache tr∆∞·ªõc
      const cacheKey = `user_exists_${email}`;
      const cached = this.cache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < 60000) {
        console.log("verifyUserExists - s·ª≠ d·ª•ng cache:", cached.data);
        return cached.data;
      }

      // ƒê·ª£i kh·ªüi t·∫°o n·∫øu c·∫ßn
      if (!this.initialized) {
        await this.initPromise;
      }

      // Chu·∫©n h√≥a email
      const normalizedEmail = email.trim().toLowerCase();

      // Th·ª±c hi·ªán t√¨m ki·∫øm th·ª±c s·ª± qua t·∫•t c·∫£ users v√¨ document ID l√† username, kh√¥ng ph·∫£i email
      const allUsersSnapshot = await getDocs(collection(this.db, "users"));
      let userExists = false;
      let foundUserData = null;

      allUsersSnapshot.forEach((doc) => {
        const userData = doc.data();
        const userEmail = userData.email?.toLowerCase() || "";

        // Ki·ªÉm tra email kh·ªõp v√† user c√≤n active v√† kh√¥ng b·ªã kh√≥a
        if (userEmail === normalizedEmail && userData.isActive) {
          // Ki·ªÉm tra status - n·∫øu c√≥ field status v√† b·∫±ng false th√¨ coi nh∆∞ kh√¥ng t·ªìn t·∫°i
          if (userData.hasOwnProperty("status") && userData.status === false) {
            console.log("User t·ªìn t·∫°i nh∆∞ng b·ªã kh√≥a:", {
              email: normalizedEmail,
              userId: doc.id,
              status: userData.status,
            });
            userExists = false; // User b·ªã kh√≥a
          } else {
            console.log("User t·ªìn t·∫°i v√† active:", {
              email: normalizedEmail,
              userId: doc.id,
              status: userData.status || "kh√¥ng c√≥ field status",
            });
            userExists = true;
            foundUserData = userData;
          }
        }
      });

      console.log("K·∫øt qu·∫£ verifyUserExists:", {
        email: normalizedEmail,
        exists: userExists,
        foundUser: foundUserData
          ? {
              email: foundUserData.email,
              username: foundUserData.username,
              status: foundUserData.status,
            }
          : null,
      });

      // L∆∞u cache k·∫øt qu·∫£
      this.cache.set(cacheKey, {
        data: userExists,
        timestamp: Date.now(),
      });

      return userExists;
    } catch (error) {
      console.error("L·ªói khi x√°c minh ng∆∞·ªùi d√πng:", error);
      return false;
    }
  }

  // H√†m ki·ªÉm tra user c√≥ t·ªìn t·∫°i v√† tr·∫£ v·ªÅ th√¥ng tin user (cho forgot password)
  async checkUserExists(emailOrUsername) {
    try {
      // ƒê·ª£i kh·ªüi t·∫°o n·∫øu c·∫ßn
      if (!this.initialized) {
        await this.initPromise;
      }

      // Chu·∫©n h√≥a ƒë·∫ßu v√†o
      const normalizedInput = emailOrUsername.trim().toLowerCase();

      // ƒê·∫ßu ti√™n th·ª≠ t√¨m username tr·ª±c ti·∫øp
      let userDoc = await getDoc(doc(this.db, "users", normalizedInput));

      if (userDoc.exists()) {
        const userData = userDoc.data();
        if (userData.isActive) {
          return {
            id: normalizedInput,
            email: userData.email,
            username: userData.username,
            name: userData.name,
          };
        }
      }

      // N·∫øu kh√¥ng t√¨m th·∫•y, t√¨m ki·∫øm b·∫±ng email
      const allUsersSnapshot = await getDocs(collection(this.db, "users"));
      let foundUser = null;

      allUsersSnapshot.forEach((doc) => {
        const data = doc.data();
        const userEmail = data.email?.toLowerCase() || "";
        const userName = data.username?.toLowerCase() || "";

        // Ki·ªÉm tra xem ƒë·∫ßu v√†o c√≥ kh·ªõp v·ªõi email ho·∫∑c username
        if (userEmail === normalizedInput || userName === normalizedInput) {
          foundUser = { id: doc.id, ...data };
        }
      });

      return foundUser;
    } catch (error) {
      console.error("L·ªói khi ki·ªÉm tra user t·ªìn t·∫°i:", error);
      return false;
    }
  }

  // H√†m reset m·∫≠t kh·∫©u user (cho forgot password)
  async resetUserPassword(userId, newPassword) {
    try {
      // ƒê·ª£i kh·ªüi t·∫°o n·∫øu c·∫ßn
      if (!this.initialized) {
        await this.initPromise;
      }

      // Validate password
      if (!newPassword || newPassword.length < 6) {
        return {
          success: false,
          message: "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±",
        };
      }

      // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u trong Firestore
      await updateDoc(doc(this.db, "users", userId), {
        password: newPassword,
        passwordUpdatedAt: serverTimestamp(),
        passwordUpdatedBy: "password_reset",
      });

      // Log ho·∫°t ƒë·ªông b·∫£o m·∫≠t
      this.securityMonitor.logActivity("password_reset", {
        userId: userId,
        timestamp: new Date().toISOString(),
      });

      return {
        success: true,
        message: "M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t th√†nh c√¥ng",
      };
    } catch (error) {
      console.error("L·ªói khi reset m·∫≠t kh·∫©u:", error);
      return {
        success: false,
        message: "C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t m·∫≠t kh·∫©u. Vui l√≤ng th·ª≠ l·∫°i!",
      };
    }
  }

  async waitForInitialization() {
    if (this.initialized) return;
    return this.initPromise;
  }

  async login(emailOrUsername, password) {
    try {
      // Ki·ªÉm tra kh·ªüi t·∫°o nhanh
      await this.waitForInitialization();

      // Ki·ªÉm tra gi·ªõi h·∫°n t·ªëc ƒë·ªô
      const clientId = this.getClientIdentifier();
      if (!rateLimiter.isAllowed(`login_${clientId}`)) {
        this.securityMonitor.logActivity("rate_limit_exceeded", { clientId });
        return {
          success: false,
          message: "Qu√° nhi·ªÅu l·∫ßn ƒëƒÉng nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i sau.",
          field: "email",
        };
      }

      // Ki·ªÉm tra n·∫øu client b·ªã ch·∫∑n do nhi·ªÅu l·∫ßn th·∫•t b·∫°i
      if (this.securityMonitor.isBlocked(clientId)) {
        this.securityMonitor.logActivity("blocked_attempt", { clientId });
        return {
          success: false,
          message:
            "T√†i kho·∫£n t·∫°m th·ªùi b·ªã kh√≥a do nhi·ªÅu l·∫ßn ƒëƒÉng nh·∫≠p sai. Vui l√≤ng th·ª≠ l·∫°i sau 5 ph√∫t.",
          field: "email",
        };
      }

      // Chu·∫©n h√≥a ƒë·∫ßu v√†o
      const normalizedInput = emailOrUsername.trim().toLowerCase();

      // Chi·∫øn l∆∞·ª£c t√¨m ki·∫øm nhanh - th·ª≠ username tr∆∞·ªõc, sau ƒë√≥ qu√©t n·∫øu c·∫ßn
      let userDoc = null;
      let finalUserId = null;
      let foundUserData = null;

      // ƒê·∫ßu ti√™n th·ª≠ t√¨m username tr·ª±c ti·∫øp (nhanh nh·∫•t)
      userDoc = await getDoc(doc(this.db, "users", normalizedInput));

      if (userDoc.exists()) {
        foundUserData = userDoc.data();
        finalUserId = normalizedInput;
        console.log(
          "T√¨m th·∫•y ng∆∞·ªùi d√πng b·∫±ng t√¨m ki·∫øm username tr·ª±c ti·∫øp:",
          normalizedInput
        );
      } else {
        console.log(
          "T√¨m ki·∫øm username tr·ª±c ti·∫øp th·∫•t b·∫°i, ki·ªÉm tra xem ƒë·∫ßu v√†o c√≥ ph·∫£i email..."
        );

        // N·∫øu t√¨m ki·∫øm tr·ª±c ti·∫øp th·∫•t b·∫°i, c√≥ th·ªÉ l√† email - qu√©t tr∆∞·ªùng email
        // Ch·∫≠m h∆°n nh∆∞ng ch·ªâ ch·∫°y khi ai ƒë√≥ ƒëƒÉng nh·∫≠p b·∫±ng email thay v√¨ username
        const allUsersSnapshot = await getDocs(collection(this.db, "users"));
        let foundUser = null;

        allUsersSnapshot.forEach((doc) => {
          const data = doc.data();
          const userEmail = data.email?.toLowerCase() || "";
          const userName = data.username?.toLowerCase() || "";

          // Ki·ªÉm tra xem ƒë·∫ßu v√†o c√≥ kh·ªõp v·ªõi email ho·∫∑c username
          if (userEmail === normalizedInput || userName === normalizedInput) {
            foundUser = { id: doc.id, ...data };
            finalUserId = doc.id; // Document ID l√† username
            foundUserData = data;
          }
        });

        if (!foundUser) {
          this.securityMonitor.recordFailedAttempt(clientId);
          this.securityMonitor.logActivity("login_failed", {
            reason: "user_not_found",
            input: normalizedInput,
            clientId,
          });
          return {
            success: false,
            message: "T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i",
            field: "email",
          };
        }

        console.log(
          "T√¨m th·∫•y ng∆∞·ªùi d√πng b·∫±ng t√¨m ki·∫øm email:",
          foundUserData.username
        );
      }

      if (!foundUserData.isActive) {
        this.securityMonitor.recordFailedAttempt(clientId);
        this.securityMonitor.logActivity("login_failed", {
          reason: "account_inactive",
          email: foundUserData.email,
          clientId,
        });
        return {
          success: false,
          message: "T√†i kho·∫£n ƒë√£ b·ªã v√¥ hi·ªáu h√≥a",
          field: "email",
        };
      }

      // Ki·ªÉm tra tr·∫°ng th√°i kh√≥a c·ªßa user - ch·ªâ khi status field t·ªìn t·∫°i
      if (
        foundUserData.hasOwnProperty("status") &&
        foundUserData.status === false
      ) {
        this.securityMonitor.recordFailedAttempt(clientId);
        this.securityMonitor.logActivity("login_failed", {
          reason: "account_locked",
          email: foundUserData.email,
          userId: finalUserId,
          status: foundUserData.status,
          clientId,
        });
        console.log("ƒêƒÉng nh·∫≠p user b·ªã ch·∫∑n - t√†i kho·∫£n b·ªã kh√≥a:", {
          userId: finalUserId,
          email: foundUserData.email,
          status: foundUserData.status,
        });
        return {
          success: false,
          message:
            "T√†i kho·∫£n b·ªã kh√≥a, vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n ƒë·ªÉ bi·∫øt th√™m chi ti·∫øt",
          field: "email",
          isLocked: true,
        };
      }

      // Log status check ƒë·ªÉ debug
      console.log("Ki·ªÉm tra tr·∫°ng th√°i user:", {
        userId: finalUserId,
        email: foundUserData.email,
        hasStatusField: foundUserData.hasOwnProperty("status"),
        status: foundUserData.status,
        isActive: foundUserData.isActive,
      });

      if (foundUserData.password !== password) {
        this.securityMonitor.recordFailedAttempt(clientId);
        this.securityMonitor.logActivity("login_failed", {
          reason: "wrong_password",
          email: foundUserData.email,
          clientId,
        });
        return {
          success: false,
          message: "M·∫≠t kh·∫©u kh√¥ng ƒë√∫ng",
          field: "password",
        };
      }

      // X√≥a c√°c l·∫ßn th·∫•t b·∫°i khi ƒëƒÉng nh·∫≠p th√†nh c√¥ng
      this.securityMonitor.clearFailedAttempts(clientId);
      this.securityMonitor.logActivity("login_success", {
        email: foundUserData.email,
        clientId,
      });

      // T·∫°o phi√™n ng∆∞·ªùi d√πng
      const user = {
        email: foundUserData.email,
        username: foundUserData.username || foundUserData.email,
        role: foundUserData.role,
        name: foundUserData.name,
        assignedFields: foundUserData.assignedFields || [],
        loginTime: new Date().toISOString(),
      };

      this.currentUser = user;
      // S·ª≠ d·ª•ng sessionStorage thay v√¨ localStorage ƒë·ªÉ b·∫£o m·∫≠t t·ªët h∆°n
      sessionStorage.setItem("currentUser", JSON.stringify(user));

      // C·∫≠p nh·∫≠t th·ªùi gian ƒëƒÉng nh·∫≠p cu·ªëi trong Firestore
      await updateDoc(doc(this.db, "users", finalUserId), {
        lastLoginAt: serverTimestamp(),
      });

      console.log("ƒêƒÉng nh·∫≠p th√†nh c√¥ng cho:", foundUserData.email);
      return { success: true, user: user };
    } catch (error) {
      console.error("L·ªói ƒëƒÉng nh·∫≠p:", error);
      this.securityMonitor.logActivity("login_error", {
        error: error.message,
        clientId: this.getClientIdentifier(),
      });
      return {
        success: false,
        message: "C√≥ l·ªói x·∫£y ra khi ƒëƒÉng nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i!",
        field: "email",
      };
    }
  }

  getClientIdentifier() {
    // T·∫°o ƒë·ªãnh danh client b√°n-vƒ©nh vi·ªÖn
    let clientId = sessionStorage.getItem("clientId");
    if (!clientId) {
      clientId = this.generateClientId();
      sessionStorage.setItem("clientId", clientId);
    }
    return clientId;
  }

  generateClientId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    const screenSize = window.screen
      ? `${window.screen.width}x${window.screen.height}`
      : "unknown";
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;

    return btoa(`${timestamp}_${random}_${screenSize}_${tz}`).substr(0, 16);
  }

  async logout() {
    if (this.currentUser) {
      this.securityMonitor.logActivity("logout", {
        email: this.currentUser.email,
        clientId: this.getClientIdentifier(),
      });
    }

    this.currentUser = null;
    sessionStorage.removeItem("currentUser");
    sessionStorage.removeItem("clientId");

    // X√≥a t·∫•t c·∫£ d·ªØ li·ªáu localStorage bao g·ªìm remember login v√† auto-save data
    try {
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (
          key &&
          (key.startsWith("app_") ||
            key.startsWith("auth_") ||
            key.startsWith("user_") ||
            key === "remember_login")
        ) {
          keysToRemove.push(key);
        }
      }

      keysToRemove.forEach((key) => {
        localStorage.removeItem(key);
      });

      console.log("ƒê√£ x√≥a localStorage khi ƒëƒÉng xu·∫•t:", keysToRemove);
    } catch (error) {
      console.warn("Kh√¥ng th·ªÉ x√≥a localStorage khi ƒëƒÉng xu·∫•t:", error);
    }

    window.location.href = "index.html";
  }

  isLoggedIn() {
    return this.currentUser !== null;
  }

  isAdmin() {
    return this.currentUser && this.currentUser.role === "admin";
  }

  getCurrentUser() {
    return this.currentUser;
  }

  redirectToAppropriatePanel() {
    if (!this.currentUser) {
      window.location.href = "index.html";
      return;
    }

    const currentPage = window.location.pathname.split("/").pop();

    if (this.currentUser.role === "admin") {
      if (currentPage !== "admin.html") {
        window.location.href = "admin.html";
      }
    } else {
      if (currentPage !== "user.html") {
        window.location.href = "user.html";
      }
    }
  }

  requireAuth() {
    if (!this.isLoggedIn()) {
      window.location.href = "index.html";
      return false;
    }
    return true;
  }

  requireAdmin() {
    if (!this.isLoggedIn() || !this.isAdmin()) {
      window.location.href = "index.html";
      return false;
    }
    return true;
  }

  // C√°c h√†m qu·∫£n l√Ω ng∆∞·ªùi d√πng cho admin - S·ª¨A L·ªñI INDEX
  async getUsers() {
    try {
      await this.waitForInitialization();

      // X√≥a cache ƒë·ªÉ ƒë·∫£m b·∫£o l·∫•y d·ªØ li·ªáu m·ªõi nh·∫•t
      this.cache.clear();

      // Lo·∫°i b·ªè orderBy ƒë·ªÉ tr√°nh y√™u c·∫ßu index
      const q = query(
        collection(this.db, "users"),
        where("role", "==", "user")
      );

      const querySnapshot = await getDocs(q);
      const users = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();

        // ƒê·∫£m b·∫£o status field lu√¥n c√≥ gi√° tr·ªã - m·∫∑c ƒë·ªãnh l√† true (kh√¥ng b·ªã kh√≥a)
        if (!data.hasOwnProperty("status")) {
          data.status = true;
        }

        users.push({
          id: doc.id,
          ...data,
          createdAt:
            data.createdAt?.toDate?.()?.toISOString() ||
            new Date().toISOString(),
        });
      });

      // S·∫Øp x·∫øp trong JavaScript thay v√¨ Firestore
      users.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      console.log(
        "getUsers tr·∫£ v·ªÅ:",
        users.map((u) => ({
          id: u.id,
          email: u.email,
          status: u.status,
          hasStatusField: u.hasOwnProperty("status"),
        }))
      );

      return users;
    } catch (error) {
      console.error("L·ªói khi l·∫•y danh s√°ch ng∆∞·ªùi d√πng:", error);
      // D·ª± ph√≤ng: l·∫•y t·∫•t c·∫£ ng∆∞·ªùi d√πng v√† l·ªçc
      try {
        const allUsersSnapshot = await getDocs(collection(this.db, "users"));
        const users = [];
        allUsersSnapshot.forEach((doc) => {
          const data = doc.data();
          if (data.role === "user") {
            // ƒê·∫£m b·∫£o status field lu√¥n c√≥ gi√° tr·ªã
            if (!data.hasOwnProperty("status")) {
              data.status = true;
            }

            users.push({
              id: doc.id,
              ...data,
              createdAt:
                data.createdAt?.toDate?.()?.toISOString() ||
                new Date().toISOString(),
            });
          }
        });
        users.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        return users;
      } catch (fallbackError) {
        console.error("L·ªói d·ª± ph√≤ng:", fallbackError);
        return [];
      }
    }
  }

  async createUser(userData) {
    try {
      await this.waitForInitialization();

      // Ki·ªÉm tra gi·ªõi h·∫°n t·ªëc ƒë·ªô nhanh
      const clientId = this.getClientIdentifier();
      if (!rateLimiter.isAllowed(`admin_${clientId}`)) {
        return {
          success: false,
          message: "Qu√° nhi·ªÅu thao t√°c. Vui l√≤ng th·ª≠ l·∫°i sau.",
        };
      }

      // X·ª≠ l√Ω ƒë·∫ßu v√†o nhanh
      const email =
        userData.email?.trim().toLowerCase() ||
        Math.floor(Math.random() * 10000000000) + 1 + "t";
      const username = userData.username?.trim().toLowerCase();
      const password = userData.password?.trim() || "123456";
      const name = userData.name?.trim();

      // X√°c th·ª±c nhanh
      if (!username) {
        return { success: false, message: "Vui l√≤ng nh·∫≠p t√™n ƒëƒÉng nh·∫≠p!" };
      }

      if (username.length < 3) {
        return {
          success: false,
          message: "T√™n ƒëƒÉng nh·∫≠p ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±!",
        };
      }

      // S·ª≠ d·ª•ng username l√†m document ID ƒë·ªÉ t√¨m ki·∫øm nhanh
      const userId = username;

      // Ki·ªÉm tra nhanh ƒë∆°n l·∫ª - th·ª≠ l·∫•y ng∆∞·ªùi d√πng theo username (document ID)
      const existingUser = await getDoc(doc(this.db, "users", userId));
      if (existingUser.exists()) {
        return { success: false, message: "T√™n ng∆∞·ªùi d√πng ƒë√£ t·ªìn t·∫°i!" };
      }

      // Ki·ªÉm tra email tr√πng l·∫∑p - qu√©t qua t·∫•t c·∫£ users
      if (email && typeof email === "string") {
        const allUsersSnapshot = await getDocs(collection(this.db, "users"));
        let emailExists = false;

        allUsersSnapshot.forEach((doc) => {
          const userData = doc.data();
          if (
            userData.email &&
            userData.email.toLowerCase() === email &&
            userData.isActive
          ) {
            emailExists = true;
          }
        });

        if (emailExists) {
          return {
            success: false,
            message: "Email ƒë√£ t·ªìn t·∫°i!",
          };
        }
      }

      // T·∫°o ƒë·ªëi t∆∞·ª£ng ng∆∞·ªùi d√πng nhanh
      const newUser = {
        email: email,
        username: username,
        password: password,
        name: name,
        role: "user",
        assignedFields: userData.assignedFields || [],
        createdAt: serverTimestamp(),
        createdBy: this.currentUser.email,
        isActive: true,
        status: true, // true = kh√¥ng b·ªã kh√≥a, false = b·ªã kh√≥a
      };

      // Thao t√°c ghi ƒë∆°n l·∫ª nhanh
      await setDoc(doc(this.db, "users", userId), newUser);

      console.log("User ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng v·ªõi status true:", {
        userId: userId,
        email: email,
        status: newUser.status,
        isActive: newUser.isActive,
      });

      return {
        success: true,
        user: {
          id: userId,
          ...newUser,
          createdAt: new Date().toISOString(),
        },
      };
    } catch (error) {
      console.error("L·ªói t·∫°o user:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi t·∫°o ng∆∞·ªùi d√πng!" };
    }
  }

  async updateUser(userId, userData) {
    try {
      await this.waitForInitialization();

      // Ki·ªÉm tra email tr√πng l·∫∑p n·∫øu email ƒë∆∞·ª£c c·∫≠p nh·∫≠t
      if (userData.email) {
        const normalizedEmail = userData.email.trim().toLowerCase();

        // Qu√©t qua t·∫•t c·∫£ users ƒë·ªÉ ki·ªÉm tra email tr√πng l·∫∑p
        const allUsersSnapshot = await getDocs(collection(this.db, "users"));
        let emailExists = false;

        allUsersSnapshot.forEach((doc) => {
          const existingUserData = doc.data();
          // Ki·ªÉm tra email tr√πng l·∫∑p v·ªõi user kh√°c (kh√¥ng ph·∫£i ch√≠nh user ƒëang ƒë∆∞·ª£c update)
          if (
            doc.id !== userId &&
            existingUserData.email &&
            existingUserData.email.toLowerCase() === normalizedEmail &&
            existingUserData.isActive
          ) {
            emailExists = true;
          }
        });

        if (emailExists) {
          return {
            success: false,
            message: "Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng b·ªüi ng∆∞·ªùi d√πng kh√°c!",
          };
        }

        // Chu·∫©n h√≥a email trong userData
        userData.email = normalizedEmail;
      }

      await updateDoc(doc(this.db, "users", userId), {
        ...userData,
        updatedAt: serverTimestamp(),
        updatedBy: this.currentUser.email,
      });

      const updatedDoc = await getDoc(doc(this.db, "users", userId));
      const updatedData = updatedDoc.data();

      return {
        success: true,
        user: {
          id: userId,
          ...updatedData,
        },
      };
    } catch (error) {
      console.error("L·ªói c·∫≠p nh·∫≠t user:", error);
      return {
        success: false,
        message: "C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t ng∆∞·ªùi d√πng!",
      };
    }
  }

  async deleteUser(userId) {
    try {
      await this.waitForInitialization();

      console.log("deleteUser ƒë∆∞·ª£c g·ªçi v·ªõi userId:", userId);

      // L·∫•y th√¥ng tin user hi·ªán t·∫°i ƒë·ªÉ ki·ªÉm tra status
      const userDoc = await getDoc(doc(this.db, "users", userId));
      if (!userDoc.exists()) {
        console.log("Kh√¥ng t√¨m th·∫•y user:", userId);
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng!" };
      }

      const userData = userDoc.data();
      console.log("D·ªØ li·ªáu user hi·ªán t·∫°i:", {
        userId: userId,
        hasStatus: userData.hasOwnProperty("status"),
        currentStatus: userData.status,
        email: userData.email,
      });

      // N·∫øu user ch∆∞a c√≥ field status, coi nh∆∞ ƒëang m·ªü (true) v√† c·∫ßn set l·∫°i
      let currentStatus = true; // M·∫∑c ƒë·ªãnh l√† kh√¥ng b·ªã kh√≥a
      if (userData.hasOwnProperty("status")) {
        currentStatus = userData.status;
      } else {
        console.log("User kh√¥ng c√≥ field status, ƒë·∫∑t m·∫∑c ƒë·ªãnh true");
        // C·∫≠p nh·∫≠t user v·ªõi status m·∫∑c ƒë·ªãnh tr∆∞·ªõc
        await updateDoc(doc(this.db, "users", userId), {
          status: true,
          updatedAt: serverTimestamp(),
          updatedBy: this.currentUser.email,
          statusAddedBy: "system_default",
        });
        currentStatus = true;
      }

      const newStatus = !currentStatus; // Toggle status

      console.log("Thay ƒë·ªïi status:", {
        currentStatus: currentStatus,
        newStatus: newStatus,
        action: newStatus ? "m·ªü kh√≥a" : "kh√≥a",
      });

      // C·∫≠p nh·∫≠t status thay v√¨ x√≥a
      const updateData = {
        status: newStatus,
        updatedAt: serverTimestamp(),
        updatedBy: this.currentUser.email,
        lockReason: newStatus ? null : "Kh√≥a b·ªüi qu·∫£n tr·ªã vi√™n",
        lockedAt: newStatus ? null : serverTimestamp(),
      };

      console.log("C·∫≠p nh·∫≠t user v·ªõi d·ªØ li·ªáu:", updateData);

      await updateDoc(doc(this.db, "users", userId), updateData);

      console.log("C·∫≠p nh·∫≠t user ho√†n th√†nh th√†nh c√¥ng");

      // Log ho·∫°t ƒë·ªông b·∫£o m·∫≠t
      this.securityMonitor.logActivity("user_status_changed", {
        targetUserId: userId,
        targetUserEmail: userData.email,
        newStatus: newStatus,
        changedBy: this.currentUser.email,
        action: newStatus ? "m·ªü kh√≥a" : "kh√≥a",
      });

      const action = newStatus ? "m·ªü kh√≥a" : "kh√≥a";
      const result = {
        success: true,
        message: `ƒê√£ ${action} ng∆∞·ªùi d√πng ${
          userData.email || userData.username
        } th√†nh c√¥ng!`,
        newStatus: newStatus,
        userEmail: userData.email || userData.username,
        action: action,
      };

      console.log("K·∫øt qu·∫£ deleteUser:", result);
      return result;
    } catch (error) {
      console.error("L·ªói khi thay ƒë·ªïi tr·∫°ng th√°i ng∆∞·ªùi d√πng:", error);
      return {
        success: false,
        message: "C√≥ l·ªói x·∫£y ra khi thay ƒë·ªïi tr·∫°ng th√°i ng∆∞·ªùi d√πng!",
        error: error.message,
      };
    }
  }

  // Function ri√™ng ƒë·ªÉ toggle user status v·ªõi th√¥ng b√°o chi ti·∫øt
  async toggleUserStatus(userId) {
    return await this.deleteUser(userId); // S·ª≠ d·ª•ng l·∫°i logic deleteUser
  }

  // Qu·∫£n l√Ω tr∆∞·ªùng - S·ª¨A L·ªñI INDEX V√Ä TH√äM KI·ªÇM SO√ÅT TRUY C·∫¨P TR∆Ø·ªúNG
  async getFields() {
    try {
      await this.waitForInitialization();

      // Lo·∫°i b·ªè orderBy ƒë·ªÉ tr√°nh y√™u c·∫ßu index
      const q = query(
        collection(this.db, "fields"),
        where("isActive", "==", true)
      );

      const querySnapshot = await getDocs(q);
      const allFields = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();
        allFields.push({
          id: doc.id,
          ...data,
          createdAt:
            data.createdAt?.toDate?.()?.toISOString() ||
            new Date().toISOString(),
          data: data.data || [],
        });
      });

      // S·∫Øp x·∫øp trong JavaScript thay v√¨ Firestore
      allFields.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

      // N·∫øu ng∆∞·ªùi d√πng l√† admin, tr·∫£ v·ªÅ t·∫•t c·∫£ tr∆∞·ªùng
      if (this.isAdmin()) {
        return allFields;
      }

      // N·∫øu ng∆∞·ªùi d√πng l√† ng∆∞·ªùi d√πng th∆∞·ªùng, ch·ªâ tr·∫£ v·ªÅ tr∆∞·ªùng ƒë∆∞·ª£c g√°n
      if (this.currentUser && this.currentUser.assignedFields) {
        const assignedFields = allFields.filter((field) =>
          this.currentUser.assignedFields.includes(field.id)
        );
        return assignedFields;
      }

      // N·∫øu kh√¥ng c√≥ tr∆∞·ªùng ƒë∆∞·ª£c g√°n, tr·∫£ v·ªÅ m·∫£ng r·ªóng
      return [];
    } catch (error) {
      console.error("L·ªói khi l·∫•y danh s√°ch tr∆∞·ªùng:", error);
      // D·ª± ph√≤ng: l·∫•y t·∫•t c·∫£ tr∆∞·ªùng v√† l·ªçc
      try {
        const allFieldsSnapshot = await getDocs(collection(this.db, "fields"));
        const allFields = [];
        allFieldsSnapshot.forEach((doc) => {
          const data = doc.data();
          if (data.isActive === true) {
            allFields.push({
              id: doc.id,
              ...data,
              createdAt:
                data.createdAt?.toDate?.()?.toISOString() ||
                new Date().toISOString(),
              data: data.data || [],
            });
          }
        });
        allFields.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        // √Åp d·ª•ng ki·ªÉm so√°t truy c·∫≠p tr∆∞·ªùng
        if (this.isAdmin()) {
          return allFields;
        }

        if (this.currentUser && this.currentUser.assignedFields) {
          const assignedFields = allFields.filter((field) =>
            this.currentUser.assignedFields.includes(field.id)
          );
          return assignedFields;
        }

        return [];
      } catch (fallbackError) {
        console.error("L·ªói d·ª± ph√≤ng:", fallbackError);
        return [];
      }
    }
  }

  // L·∫•y t·∫•t c·∫£ fields cho admin (b·ªè qua ki·ªÉm so√°t truy c·∫≠p)
  async getAllFieldsForAdmin() {
    try {
      await this.waitForInitialization();

      const q = query(
        collection(this.db, "fields"),
        where("isActive", "==", true)
      );
      const querySnapshot = await getDocs(q);
      const fields = [];

      querySnapshot.forEach((doc) => {
        const data = doc.data();
        fields.push({
          id: doc.id,
          ...data,
          createdAt:
            data.createdAt?.toDate?.()?.toISOString() ||
            new Date().toISOString(),
          data: data.data || [],
        });
      });

      fields.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
      return fields;
    } catch (error) {
      console.error("L·ªói l·∫•y t·∫•t c·∫£ fields cho admin:", error);
      return [];
    }
  }

  async createField(fieldData) {
    try {
      await this.waitForInitialization();

      // Ki·ªÉm tra ƒë∆°n gi·∫£n m√† kh√¥ng c·∫ßn query ph·ª©c t·∫°p
      const allFieldsSnapshot = await getDocs(collection(this.db, "fields"));
      let fieldExists = false;

      allFieldsSnapshot.forEach((doc) => {
        const data = doc.data();
        if (data.name === fieldData.name && data.isActive === true) {
          fieldExists = true;
        }
      });

      if (fieldExists) {
        return { success: false, message: "Tr∆∞·ªùng ƒë√£ t·ªìn t·∫°i!" };
      }

      const newField = {
        name: fieldData.name,
        description: fieldData.description || "",
        data: [],
        createdAt: serverTimestamp(),
        createdBy: this.currentUser.email,
        isActive: true,
      };

      const docRef = doc(collection(this.db, "fields"));
      await setDoc(docRef, newField);

      return {
        success: true,
        field: {
          id: docRef.id,
          ...newField,
          createdAt: new Date().toISOString(),
        },
      };
    } catch (error) {
      console.error("L·ªói t·∫°o field:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi t·∫°o tr∆∞·ªùng!" };
    }
  }

  async updateField(fieldId, updateData) {
    try {
      await this.waitForInitialization();

      const fieldRef = doc(this.db, "fields", fieldId);

      // Th√™m timestamp
      const dataToUpdate = {
        ...updateData,
        updatedAt: new Date().toISOString(),
        updatedBy: this.currentUser.email,
      };

      await updateDoc(fieldRef, dataToUpdate);

      return { success: true };
    } catch (error) {
      console.error("L·ªói c·∫≠p nh·∫≠t tr∆∞·ªùng:", error);
      return {
        success: false,
        message: "C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t tr∆∞·ªùng!",
      };
    }
  }

  async deleteField(fieldId) {
    try {
      await this.waitForInitialization();

      // Thay v√¨ x√≥a, ch√∫ng ta s·∫Ω v√¥ hi·ªáu h√≥a tr∆∞·ªùng
      await updateDoc(doc(this.db, "fields", fieldId), {
        isActive: false,
        deletedAt: serverTimestamp(),
        deletedBy: this.currentUser.email,
      });

      return { success: true };
    } catch (error) {
      console.error("L·ªói khi x√≥a tr∆∞·ªùng:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi x√≥a tr∆∞·ªùng!" };
    }
  }

  // Qu·∫£n l√Ω d·ªØ li·ªáu v·ªõi ki·ªÉm so√°t truy c·∫≠p tr∆∞·ªùng
  async addDataToField(fieldId, data) {
    try {
      await this.waitForInitialization();

      // Gi·ªõi h·∫°n t·ªëc ƒë·ªô cho thao t√°c d·ªØ li·ªáu
      const clientId = this.getClientIdentifier();
      if (!rateLimiter.isAllowed(`data_${clientId}`)) {
        return {
          success: false,
          message: "Qu√° nhi·ªÅu thao t√°c. Vui l√≤ng th·ª≠ l·∫°i sau.",
        };
      }

      // Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ quy·ªÅn truy c·∫≠p tr∆∞·ªùng n√†y kh√¥ng
      if (!this.isAdmin()) {
        if (
          !this.currentUser.assignedFields ||
          !this.currentUser.assignedFields.includes(fieldId)
        ) {
          return {
            success: false,
            message: "B·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p tr∆∞·ªùng n√†y!",
          };
        }
      }

      const fieldDoc = await getDoc(doc(this.db, "fields", fieldId));
      if (!fieldDoc.exists()) {
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng!" };
      }

      const fieldData = fieldDoc.data();
      const existingData = fieldData.data || [];

      // Ki·ªÉm tra tr√πng l·∫∑p
      if (
        existingData.some(
          (item) => item.value.toLowerCase() === data.trim().toLowerCase()
        )
      ) {
        return { success: false, message: "D·ªØ li·ªáu ƒë√£ t·ªìn t·∫°i!" };
      }

      const newDataItem = {
        id: this.generateDataId(),
        value: data.trim(),
        addedAt: new Date().toISOString(),
        addedBy: this.currentUser.email,
      };

      await updateDoc(doc(this.db, "fields", fieldId), {
        data: arrayUnion(newDataItem),
      });

      return {
        success: true,
        data: newDataItem,
      };
    } catch (error) {
      console.error("L·ªói khi th√™m d·ªØ li·ªáu:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi th√™m d·ªØ li·ªáu!" };
    }
  }

  async removeDataFromField(fieldId, dataId) {
    try {
      await this.waitForInitialization();

      const fieldDoc = await getDoc(doc(this.db, "fields", fieldId));
      if (!fieldDoc.exists()) {
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y tr∆∞·ªùng!" };
      }

      const fieldData = fieldDoc.data();
      const dataToRemove = (fieldData.data || []).find(
        (item) => item.id === dataId
      );

      if (!dataToRemove) {
        return { success: false, message: "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu!" };
      }

      await updateDoc(doc(this.db, "fields", fieldId), {
        data: arrayRemove(dataToRemove),
      });

      return { success: true };
    } catch (error) {
      console.error("L·ªói khi x√≥a d·ªØ li·ªáu:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi x√≥a d·ªØ li·ªáu!" };
    }
  }

  // C√°c h√†m ti·ªán √≠ch
  generateDataId() {
    return "data_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
  }

  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  // C√°c h√†m xu·∫•t d·ªØ li·ªáu
  async exportData(format = "excel") {
    try {
      const fields = await this.getFields();

      if (format === "excel") {
        return this.exportToExcel(fields);
      }

      return { success: false, message: "ƒê·ªãnh d·∫°ng kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£!" };
    } catch (error) {
      console.error("L·ªói khi xu·∫•t d·ªØ li·ªáu:", error);
      return { success: false, message: "C√≥ l·ªói x·∫£y ra khi xu·∫•t d·ªØ li·ªáu!" };
    }
  }

  async exportToExcel(fields) {
    // S·∫Ω ƒë∆∞·ª£c tri·ªÉn khai v·ªõi th∆∞ vi·ªán nh∆∞ SheetJS
    // Hi·ªán t·∫°i, tr·∫£ v·ªÅ ƒë·ªãnh d·∫°ng CSV
    let csvContent = "data:text/csv;charset=utf-8,";

    // Ti√™u ƒë·ªÅ
    csvContent += "Tr∆∞·ªùng,D·ªØ li·ªáu,Ng∆∞·ªùi th√™m,Ng√†y th√™m\n";

    // D·ªØ li·ªáu
    fields.forEach((field) => {
      (field.data || []).forEach((item) => {
        csvContent += `"${field.name}","${item.value}","${
          item.addedBy
        }","${new Date(item.addedAt).toLocaleString("vi-VN")}"\n`;
      });
    });

    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute(
      "download",
      `data_export_${new Date().toISOString().split("T")[0]}.csv`
    );
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    return { success: true };
  }
}

// Kh·ªüi t·∫°o h·ªá th·ªëng x√°c th·ª±c
const authSystem = new AuthSystem();

// H·ªó tr·ª£ legacy
const auth = authSystem;

// Xu·∫•t ƒë·ªÉ s·ª≠ d·ª•ng module
export { authSystem, auth };
